// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// CatalogDataCategoryAttributeInterface catalog data category attribute interface
// swagger:model catalog-data-category-attribute-interface
type CatalogDataCategoryAttributeInterface struct {

	// Apply to value for the element
	ApplyTo []string `json:"apply_to"`

	// Code of the attribute.
	// Required: true
	AttributeCode *string `json:"attribute_code"`

	// Id of the attribute.
	AttributeID int64 `json:"attribute_id,omitempty"`

	// Backend model
	BackendModel string `json:"backend_model,omitempty"`

	// Backend type.
	BackendType string `json:"backend_type,omitempty"`

	// Custom attributes values.
	CustomAttributes []*FrameworkAttributeInterface `json:"custom_attributes"`

	// Frontend label for default store
	DefaultFrontendLabel string `json:"default_frontend_label,omitempty"`

	// Default value for the element.
	DefaultValue string `json:"default_value,omitempty"`

	// Entity type id
	// Required: true
	EntityTypeID *string `json:"entity_type_id"`

	// extension attributes
	ExtensionAttributes CatalogDataEavAttributeExtensionInterface `json:"extension_attributes,omitempty"`

	// Frontend class of attribute
	FrontendClass string `json:"frontend_class,omitempty"`

	// HTML for input element.
	// Required: true
	FrontendInput *string `json:"frontend_input"`

	// Frontend label for each store
	// Required: true
	FrontendLabels []*EavDataAttributeFrontendLabelInterface `json:"frontend_labels"`

	// The attribute can be compared on the frontend
	IsComparable string `json:"is_comparable,omitempty"`

	// It used in layered navigation
	IsFilterable bool `json:"is_filterable,omitempty"`

	// It is filterable in catalog product grid
	IsFilterableInGrid bool `json:"is_filterable_in_grid,omitempty"`

	// It is used in search results layered navigation
	IsFilterableInSearch bool `json:"is_filterable_in_search,omitempty"`

	// The HTML tags are allowed on the frontend
	IsHTMLAllowedOnFront bool `json:"is_html_allowed_on_front,omitempty"`

	// Attribute is required.
	// Required: true
	IsRequired *bool `json:"is_required"`

	// The attribute can be used in Quick Search
	IsSearchable string `json:"is_searchable,omitempty"`

	// This is a unique attribute
	IsUnique string `json:"is_unique,omitempty"`

	// The attribute can be used for promo rules
	IsUsedForPromoRules string `json:"is_used_for_promo_rules,omitempty"`

	// It is used in catalog product grid
	IsUsedInGrid bool `json:"is_used_in_grid,omitempty"`

	// Current attribute has been defined by a user.
	IsUserDefined bool `json:"is_user_defined,omitempty"`

	// Attribute is visible on frontend.
	IsVisible bool `json:"is_visible,omitempty"`

	// The attribute can be used in Advanced Search
	IsVisibleInAdvancedSearch string `json:"is_visible_in_advanced_search,omitempty"`

	// It is visible in catalog product grid
	IsVisibleInGrid bool `json:"is_visible_in_grid,omitempty"`

	// The attribute is visible on the frontend
	IsVisibleOnFront string `json:"is_visible_on_front,omitempty"`

	// WYSIWYG flag
	IsWysiwygEnabled bool `json:"is_wysiwyg_enabled,omitempty"`

	// The note attribute for the element.
	Note string `json:"note,omitempty"`

	// Options of the attribute (key => value pairs for select)
	Options []*EavDataAttributeOptionInterface `json:"options"`

	// Position
	Position int64 `json:"position,omitempty"`

	// Attribute scope
	Scope string `json:"scope,omitempty"`

	// Source model
	SourceModel string `json:"source_model,omitempty"`

	// It is used for sorting in product listing
	UsedForSortBy bool `json:"used_for_sort_by,omitempty"`

	// The attribute can be used in product listing
	UsedInProductListing string `json:"used_in_product_listing,omitempty"`

	// Validation rules.
	ValidationRules []*EavDataAttributeValidationRuleInterface `json:"validation_rules"`
}

// Validate validates this catalog data category attribute interface
func (m *CatalogDataCategoryAttributeInterface) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAttributeCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCustomAttributes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEntityTypeID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFrontendInput(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFrontendLabels(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsRequired(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValidationRules(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CatalogDataCategoryAttributeInterface) validateAttributeCode(formats strfmt.Registry) error {

	if err := validate.Required("attribute_code", "body", m.AttributeCode); err != nil {
		return err
	}

	return nil
}

func (m *CatalogDataCategoryAttributeInterface) validateCustomAttributes(formats strfmt.Registry) error {

	if swag.IsZero(m.CustomAttributes) { // not required
		return nil
	}

	for i := 0; i < len(m.CustomAttributes); i++ {
		if swag.IsZero(m.CustomAttributes[i]) { // not required
			continue
		}

		if m.CustomAttributes[i] != nil {
			if err := m.CustomAttributes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("custom_attributes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CatalogDataCategoryAttributeInterface) validateEntityTypeID(formats strfmt.Registry) error {

	if err := validate.Required("entity_type_id", "body", m.EntityTypeID); err != nil {
		return err
	}

	return nil
}

func (m *CatalogDataCategoryAttributeInterface) validateFrontendInput(formats strfmt.Registry) error {

	if err := validate.Required("frontend_input", "body", m.FrontendInput); err != nil {
		return err
	}

	return nil
}

func (m *CatalogDataCategoryAttributeInterface) validateFrontendLabels(formats strfmt.Registry) error {

	if err := validate.Required("frontend_labels", "body", m.FrontendLabels); err != nil {
		return err
	}

	for i := 0; i < len(m.FrontendLabels); i++ {
		if swag.IsZero(m.FrontendLabels[i]) { // not required
			continue
		}

		if m.FrontendLabels[i] != nil {
			if err := m.FrontendLabels[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("frontend_labels" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CatalogDataCategoryAttributeInterface) validateIsRequired(formats strfmt.Registry) error {

	if err := validate.Required("is_required", "body", m.IsRequired); err != nil {
		return err
	}

	return nil
}

func (m *CatalogDataCategoryAttributeInterface) validateOptions(formats strfmt.Registry) error {

	if swag.IsZero(m.Options) { // not required
		return nil
	}

	for i := 0; i < len(m.Options); i++ {
		if swag.IsZero(m.Options[i]) { // not required
			continue
		}

		if m.Options[i] != nil {
			if err := m.Options[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("options" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CatalogDataCategoryAttributeInterface) validateValidationRules(formats strfmt.Registry) error {

	if swag.IsZero(m.ValidationRules) { // not required
		return nil
	}

	for i := 0; i < len(m.ValidationRules); i++ {
		if swag.IsZero(m.ValidationRules[i]) { // not required
			continue
		}

		if m.ValidationRules[i] != nil {
			if err := m.ValidationRules[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("validation_rules" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *CatalogDataCategoryAttributeInterface) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CatalogDataCategoryAttributeInterface) UnmarshalBinary(b []byte) error {
	var res CatalogDataCategoryAttributeInterface
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
